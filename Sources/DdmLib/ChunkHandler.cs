using System;
using System.Diagnostics;
using Dot42.DdmLib.support;

/*
 * Copyright (C) 2007 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

namespace Dot42.DdmLib
{
    /// <summary>
	/// Subclass this with a class that handles one or more chunk types.
	/// </summary>
	internal abstract class ChunkHandler
	{

		public const int CHUNK_HEADER_LEN = 8; // 4-byte type, 4-byte len
		public static readonly ByteOrder CHUNK_ORDER = ByteOrder.BIG_ENDIAN;

		public static readonly int CHUNK_FAIL = type("FAIL");

		internal ChunkHandler()
		{
		}

		/// <summary>
		/// Client is ready.  The monitor thread calls this method on all
		/// handlers when the client is determined to be DDM-aware (usually
		/// after receiving a HELO response.)
		/// 
		/// The handler can use this opportunity to initialize client-side
		/// activity.  Because there's a fair chance we'll want to send a
		/// message to the client, this method can throw an IOException.
		/// </summary>
//JAVA TO C# CONVERTER WARNING: Method 'throws' clauses are not available in .NET:
//ORIGINAL LINE: abstract void clientReady(Client client) throws java.io.IOException;
		internal abstract void clientReady(Client client);

		/// <summary>
		/// Client has gone away.  Can be used to clean up any resources
		/// associated with this client connection.
		/// </summary>
		internal abstract void clientDisconnected(Client client);

		/// <summary>
		/// Handle an incoming chunk.  The data, of chunk type "type", begins
		/// at the start of "data" and continues to data.limit().
		/// 
		/// If "isReply" is set, then "msgId" will be the ID of the request
		/// we sent to the client.  Otherwise, it's the ID generated by the
		/// client for this event.  Note that it's possible to receive chunks
		/// in reply packets for which we are not registered.
		/// 
		/// The handler may not modify the contents of "data".
		/// </summary>
		internal abstract void handleChunk(Client client, int type, ByteBuffer data, bool isReply, int msgId);

		/// <summary>
		/// Handle chunks not recognized by handlers.  The handleChunk() method
		/// in sub-classes should call this if the chunk type isn't recognized.
		/// </summary>
		protected internal virtual void handleUnknownChunk(Client client, int type, ByteBuffer data, bool isReply, int msgId)
		{
			if (type == CHUNK_FAIL)
			{
				int errorCode, msgLen;
				string msg;

                errorCode = data.getInt();
                msgLen = data.getInt();
				msg = getString(data, msgLen);
				Log.w("ddms", "WARNING: failure code=" + errorCode + " msg=" + msg);
			}
			else
			{
				Log.w("ddms", "WARNING: received unknown chunk " + name(type) + ": len=" + data.limit + ", reply=" + isReply + ", msgId=0x" + msgId.toHexString());
			}
			Log.w("ddms", "         client " + client + ", handler " + this);
		}


		/// <summary>
		/// Utility function to copy a String out of a ByteBuffer.
		/// 
		/// This is here because multiple chunk handlers can make use of it,
		/// and there's nowhere better to put it.
		/// </summary>
		internal static string getString(ByteBuffer buf, int len)
		{
			char[] data = new char[len];
			for (int i = 0; i < len; i++)
			{
				data[i] = buf.getChar();
			}
			return new string(data);
		}

		/// <summary>
		/// Utility function to copy a String into a ByteBuffer.
		/// </summary>
		internal static void putString(ByteBuffer buf, string str)
		{
			int len = str.Length;
			for (int i = 0; i < len; i++)
			{
				buf.putChar(str[i]);
			}
		}

		/// <summary>
		/// Convert a 4-character string to a 32-bit type.
		/// </summary>
		internal static int type(string typeName)
		{
			int val = 0;

			if (typeName.Length != 4)
			{
				Log.e("ddms", "Type name must be 4 letter long");
				throw new Exception("Type name must be 4 letter long");
			}

			for (int i = 0; i < 4; i++)
			{
				val <<= 8;
				val |= (byte) typeName[i];
			}

			return val;
		}

		/// <summary>
		/// Convert an integer type to a 4-character string.
		/// </summary>
		internal static string name(int type)
		{
			char[] ascii = new char[4];

			ascii[0] = (char)((type >> 24) & 0xff);
			ascii[1] = (char)((type >> 16) & 0xff);
			ascii[2] = (char)((type >> 8) & 0xff);
			ascii[3] = (char)(type & 0xff);

			return new string(ascii);
		}

		/// <summary>
		/// Allocate a ByteBuffer with enough space to hold the JDWP packet
		/// header and one chunk header in addition to the demands of the
		/// chunk being created.
		/// 
		/// "maxChunkLen" indicates the size of the chunk contents only.
		/// </summary>
		internal static ByteBuffer allocBuffer(int maxChunkLen)
		{
			var buf = ByteBuffer.allocate(JdwpPacket.JDWP_HEADER_LEN + 8 + maxChunkLen);
			buf.order=(CHUNK_ORDER);
			return buf;
		}

		/// <summary>
		/// Return the slice of the JDWP packet buffer that holds just the
		/// chunk data.
		/// </summary>
		internal static ByteBuffer getChunkDataBuf(ByteBuffer jdwpBuf)
		{
			ByteBuffer slice;

			Debug.Assert(jdwpBuf.position == 0);

			jdwpBuf.position= JdwpPacket.JDWP_HEADER_LEN + CHUNK_HEADER_LEN;
			slice = jdwpBuf.slice();
			slice.order = CHUNK_ORDER;
			jdwpBuf.position = 0;

			return slice;
		}

		/// <summary>
		/// Write the chunk header at the start of the chunk.
		/// 
		/// Pass in the byte buffer returned by JdwpPacket.getPayload().
		/// </summary>
		internal static void finishChunkPacket(JdwpPacket packet, int type, int chunkLen)
		{
			ByteBuffer buf = packet.payload;

			buf.putInt(0x00, type);
			buf.putInt(0x04, chunkLen);

			packet.finishPacket(CHUNK_HEADER_LEN + chunkLen);
		}

		/// <summary>
		/// Check that the client is opened with the proper debugger port for the
		/// specified application name, and if not, reopen it. </summary>
		/// <param name="client"> </param>
		/// <param name="uiThread"> </param>
		/// <param name="appName">
		/// @return </param>
		protected internal static Client checkDebuggerPortForAppName(Client client, string appName)
		{
			DebugPortManager.IDebugPortProvider provider = DebugPortManager.provider;
			if (provider != null)
			{
				Device device = client.deviceImpl;
				int newPort = provider.getPort(device, appName);

				if (newPort != DebugPortManager.DebugPortProvider.NO_STATIC_PORT && newPort != client.debuggerListenPort)
				{

					AndroidDebugBridge bridge = AndroidDebugBridge.bridge;
					if (bridge != null)
					{
						DeviceMonitor deviceMonitor = bridge.deviceMonitor;
						if (deviceMonitor != null)
						{
							deviceMonitor.addClientToDropAndReopen(client, newPort);
							client = null;
						}
					}
				}
			}

			return client;
		}
	}


}